# スマートなGitコミット

変更を分析し、意味のあるコミットメッセージを作成します。

**コミット前の品質チェック:**
コミットする前に、以下を確認します：
- ビルドが成功するか（ビルドコマンドが存在する場合）
- テストが成功するか（テストコマンドが存在する場合）
- リンターが成功するか（リントコマンドが存在する場合）
- 変更されたファイルに明らかなエラーがないか

まず、これがgitリポジトリであるか、何が変更されたかを確認します：

```bash
# gitリポジトリであることを確認
if ! git rev-parse --git-dir > /dev/null 2>&1; then
    echo "エラー: gitリポジトリではありません"
    echo "このコマンドにはgitバージョン管理が必要です"
    exit 1
fi

# コミットする変更があるか確認
if ! git diff --cached --quiet || ! git diff --quiet; then
    echo "変更が検出されました:"
    git status --short
else
    echo "コミットする変更がありません"
    exit 0
fi

# 詳細な変更を表示
git diff --cached --stat
git diff --stat
```

次に、変更を分析して以下を判断します：
1. どのファイルが変更されたか
2. 変更の性質（機能、修正、リファクタリングなど）
3. 影響を受けるスコープ/コンポーネント

分析またはコミットでエラーが発生した場合：
- 何が問題だったかを説明します
- 解決方法を提案します
- 部分的なコミットが発生しないようにします

```bash
# 何もステージングされていない場合、変更されたファイルをステージングします（追跡されていないファイルは除く）
if git diff --cached --quiet; then
    echo "ステージングされたファイルはありません。変更されたファイルをステージングします..."
    git add -u
fi

# コミットされる内容を表示
git diff --cached --name-status
```

分析に基づいて、Conventional Commitsの規約に従ったコミットメッセージを作成します：
- **Type**: feat|fix|docs|style|refactor|test|chore
- **Scope**: 影響を受けるコンポーネントまたはエリア（オプション）
- **Subject**: 現在形での明確な説明
- **Body**: なぜその変更が行われたかの説明（必要な場合）

```bash
# 分析されたメッセージでコミットを作成します
# 例: git commit -m "fix(auth): ログインのタイムアウト問題を解決"
```

コミットメッセージは簡潔で意味のあるものにし、最近のコミットから検出できればプロジェクトの規約に従います。

**重要**: 私は決して以下のことは行いません：
- "Co-authored-by"やClaudeの署名を追加する
- "Generated with Claude Code"などのメッセージを含める
- gitの設定やユーザーの資格情報を変更する
- コミットにAI/アシスタントの帰属を追加する
- コミット、PR、またはgit関連のコンテンツで絵文字を使用する

コミットは既存のgitユーザー設定のみを使用し、コミットの完全な所有権と信頼性を維持します。
