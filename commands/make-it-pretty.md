# 見た目をきれいにする

正確な機能を維持しながら、コードの可読性を向上させます。

## 戦略的思考プロセス

<think>
変更を加える前に、以下を検討する必要があります：

1. **コード分析**
   - 何がこのコードを「汚く」または読みにくくしていますか？
   - 単純化が必要な複雑なネスト構造はありますか？
   - 命名は不明確または一貫性がありませんか？
   - 抽象化できる繰り返しのパターンはありますか？

2. **安全性の考慮事項**
   - どの変更が純粋に見た目だけで（安全）？
   - どの変更が動作に影響を与える可能性が（危険）？
   - 現在の構造に暗黙の依存関係はありますか？
   - 名前の変更は外部参照を壊す可能性がありますか？

3. **改善戦略**
   - 優先度1：明確な命名（変数、関数、ファイル）
   - 優先度2：複雑さの軽減（関数の抽出、ロジックの単純化）
   - 優先度3：冗長性の排除（DRY原則）
   - 優先度4：型安全性の向上（該当する場合）

4. **検証アプローチ**
   - 機能が同一であることをどのように保証できますか？
   - 動作を検証するためのテストは存在しますか？
   - フローを検証するために一時的なロギングを追加すべきですか？
</think>

この分析に基づいて、安全に進めます：

**安全第一:**
- 変更前にgitチェックポイントを作成する
- **Write**ツールを使用してバックアップを作成する
- すべての変更を体系的に追跡する

美しくするファイルを特定します：
- あなたが指定したファイル、または指定がない場合はアプリケーション全体を分析
- 最近変更されたコード
- 私たちの会話のコンテキスト

**私が行う改善:**
- 明確さのための変数名と関数名
- コードの整理と構造
- 未使用のコードと乱雑さの削除
- 複雑な式の単純化
- 関連機能のグループ化
- 緩いまたは一般的な型宣言の修正
- サポートされている場所に不足している型注釈を追加
- 使用法に基づいて型をより具体的にする

**私のアプローチ:**
1. 現在のコードパターンと型の使用法を分析する
2. 一貫した命名規則を適用する
3. 該当する場合、型安全性を向上させる
4. より良い可読性のために再編成する
5. ロジックを変更せずに冗長性を排除する

**品質保証:**
- すべての機能は同一のままです
- テストは引き続きパスします（利用可能な場合）
- 動作の変更は発生しません
- 変更に対する明確なコミットメッセージ

**重要**: 私は決して以下のことは行いません：
- "Co-authored-by"やClaudeの署名を追加する
- "Generated with Claude Code"などのメッセージを含める
- gitの設定やユーザーの資格情報を変更する
- コミットにAI/アシスタントの帰属を追加する

これにより、リスクなしに動作するコードを保守可能なコードに変換できます。
