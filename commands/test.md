# スマートテストランナー - コンテキスト認識

現在のコンテキストに基づいてインテリジェントにテストを実行し、失敗の修正を積極的に支援します。

**最初にコンテキストを検出:**
私がどのようなコンテキストにいるかを理解させてください：

1. **コールドスタート**（以前のコンテキストなし）：
   - カバレッジ付きで完全なテストスイートを実行
   - 完全なヘルスレポートを生成
   - 慢性的な失敗を特定

2. **アクティブセッション**（あなたが機能を実装している場合）：
   - git diffで変更されたファイルを確認
   - CLAUDE.mdを読んでセッションの目標を理解
   - あなたが作業していたものだけをテスト
   - コーディング中のインクリメンタルテスト

3. **コマンド後のコンテキスト**:
   - `/scaffold`の後：新しいコンポーネントをテスト
   - `/fix-todos`の後：変更されたファイルをテスト
   - `/fix-imports`の後：以前に失敗したテストを再実行
   - `/security-scan`の後：セキュリティに焦点を当てたテスト
   - `/format`の後：迅速なスモークテストのみ

4. **デバッグコンテキスト**（以前のテスト失敗）：
   - 詳細な出力で失敗したテストに焦点を当てる
   - 戦略的なデバッグロギングを追加
   - 分離モードで実行

5. **コミット前のコンテキスト**:
   - 完全なスイート + リント + 型チェック
   - PR用のカバレッジレポート
   - スキップされたテストは許可されない

**フェーズ1：詳細なプロジェクト分析**
ネイティブツールを使用してテスト設定を理解します：
- **Glob**でプロジェクトルートの設定ファイルを検索
- **Read**でテスト設定とCI/CDワークフローを読む
- **Grep**でテストパターンを検索してテストスタイルを理解
- **Read**でテスト手順のドキュメントを読む

以下を検出します：
- テストフレームワークとランナー
- テストファイルのパターンと場所
- カバレッジ要件
- 統合テスト対単体テストの分離
- CI/CDテストコマンド

**フェーズ2：インテリジェントなテスト実行**
プロジェクトのテストフレームワークに基づいて、最大限の洞察を得るために適切なフラグを付けてテストを実行し、利用可能な場合は詳細な出力とfail-fastを使用して問題を迅速に特定します。

**ビルドとコンパイルのチェック:**
- テスト実行前にプロジェクトが正常にビルドされることを確認
- コンソール出力でコンパイルエラーを監視
- テストに影響を与える可能性のあるビルド警告をキャプチャして分析
- 不足している依存関係やバージョンの競合を確認

**リアルタイムモニタリング:**
```bash
# タイムスタンプ付きでテスト実行を監視
# stdoutとstderrの両方をキャプチャ
# タイムアウトパターンを監視
# テストがハングした場合のメモリ使用量を追跡
```

**フェーズ3：失敗分析と自動修正**
テストが失敗した場合、以下のことを行います：

1. **失敗出力を解析**して正確な問題を理解
2. **失敗したテストを読む**して期待値を理解
3. **実装を読む**してバグを見つける
4. パスする類似のテストから**パターンを分析**
5. 確信がある場合に**修正を適用**

**試みる一般的な修正:**
- 非同期/待機タイミングの問題
- モック/スタブの設定
- インポートパスの問題
- 型の不一致
- null/undefinedの処理
- 1つずつのエラー
- 環境変数の問題

**フェーズ4：高度な診断**
複雑な失敗の場合：
- 単一のテストを分離して実行
- 戦略的にデバッグロギングを追加
- テストの依存関係とセットアップ/ティアダウンを確認
- テストデータとフィクスチャを検証
- 不安定なテストパターンを分析

**ログ分析:**
- **Read**でテスト出力ログを読んで隠れたエラーを見つける
- **Grep**でコンソール出力の一般的なエラーパターンを検索
- スタックトレースを分析して正確な失敗場所を特定
- ログで環境固有の問題を確認
- リソースの競合（ポート、ファイル、データベース）を特定

**コンソールパターン検出:**
- メモリリーク（「JavaScriptヒープがメモリ不足」）
- ポートの競合（「アドレスは既に使用されています」）
- 権限エラー（「EACCES」、「許可が拒否されました」）
- タイムアウトの問題（「タイムアウト - 非同期コールバック」）
- モジュール解決の失敗
- データベース接続の問題

**フェーズ5：カバレッジと品質**
テストを修正した後：
- 利用可能な場合はカバレッジレポートを実行
- テストされていないコードパスを特定
- 不足している重要なテストを提案
- テストのアンチパターンを確認

複数の問題が見つかった場合、体系的に修正するためにtodoリストを作成します。

**ビルド失敗からの回復:**
テスト前にビルドが失敗した場合：
- コンパイルエラーを詳細に分析
- 不足している依存関係を確認
- 環境設定を検証
- エラーパターンに基づいて特定の修正を提案
- 検出された場合は不足しているパッケージのインストールを提案

**スマートなコンテキストベースの戦略:**
検出されたコンテキストに基づいて、最適なアプローチを選択します：

- **コンテキストなし**: 完全なテストの検出と実行
- **アクティブな開発**: 変更されたファイルのみのウォッチモード
- **実装後**: 新しいコードのテストカバレッジ
- **デバッグモード**: 最大限の詳細度を持つ分離されたテスト
- **デプロイ前**: 完全な検証スイート

**インテリジェントなテスト選択:**
```bash
# コンテキスト: UserServiceを実装した後
# 実行内容: UserServiceのテスト + それを使用する統合テスト

# コンテキスト: /scaffold user-authの後
# 実行内容: 新しいuser-authのテスト + スモークテスト

# コンテキスト: 失敗したテストの修正中
# 実行内容: デバッグ情報付きの特定の失敗したテストのみ
```

**セッション認識:**
- CLAUDE.mdからセッションの目標を読む
- セッション中に変更されたすべてのファイルを追跡
- セッションの目的に基づいてテストに優先順位を付ける
- 最後にセッションのテストレポートを生成

**他のコマンドとの統合:**
- `/test`の失敗後 → `/create-todos`で修正を追跡
- 複雑な失敗 → `/explain-like-senior`で詳細な分析
- テストの改善 → `/review`で品質チェック
- セッションのテスト → `/session-end`にテストの要約を含める

**重要**: 私は決して以下のことは行いません：
- 不正にパスするようにテストを変更する
- 修正せずに失敗したテストを削除する
- テストカバレッジを減らす
- テストの完全性を損なう
- "Co-authored-by"やClaudeの署名を追加する
- "Generated with Claude Code"などのメッセージを含める
- gitの設定やユーザーの資格情報を変更する
- コミットにAI/アシスタントの帰属を追加する

これにより、開発速度を最大化しながら、テストがコードを真に検証することが保証されます。
