# インテリジェントリファクタリングエンジン

構造、可読性、保守性を向上させながら機能を維持し、体系的にコードを再構築するのを手伝います。

引数: `$ARGUMENTS` - ファイル、ディレクトリ、またはリファクタリングの範囲

**主な特徴：すべての変更後に組み込まれた検証と改良により、何も壊れず、コードが取り残されないことを保証します。AIはリファクタリングプロセス中に自身のミスを自動的に修正します。**

**セッションファイルの場所：常に現在のディレクトリのrefactor/フォルダを使用してください**

## セッションインテリジェンス

セッションをまたいでリファクタリングの継続性を維持します：

**セッションファイル（現在のプロジェクト内）:**
- `refactor/plan.md` - 進捗追跡付きのリファクタリング計画
- `refactor/state.json` - 現在の状態と完了したアクション

**重要:** `refactor`フォルダは現在のプロジェクトディレクトリに作成されます。アクセスするには`refactor/`を使用してください。

**自動検出:**
- セッションが存在する場合：最後のチェックポイントから再開
- セッションがない場合：新しいリファクタリング計画を作成
- コマンド：`resume`、`continue`、`status`、`new`

**正しいパスの使用例：**
```
# 正しい - 現在のプロジェクトを検索：
Read refactor/state.json
LS refactor

# 間違い - これらは失敗します：
Read ../../../refactor/state.json
Read $HOME/.claude/refactor/state.json
```

## フェーズ1：初期設定と分析

### 複雑なリファクタリングのための拡張思考

複雑なリファクタリングシナリオでは、包括的な戦略を開発するために拡張思考を使用します：

<think>
複雑なアーキテクチャのリファクタリングに直面した場合：
- 機能を維持する複数ステップの変換パス
- 各変換のリスク軽減戦略
- 依存関係グラフの分析と更新順序
- 異なるアプローチのパフォーマンスへの影響
- 下位互換性の要件
- 各ステップを検証するためのテスト戦略
</think>

**拡張分析のトリガー:**
- 大規模なアーキテクチャの変更
- 複雑な依存関係の解消
- パフォーマンスが重要なリファクタリング
- レガシーシステムの近代化

**セッションチェックのための必須の最初のステップ:**
```
ステップ1：現在のディレクトリでrefactorディレクトリを確認
コマンド：LS refactor

ステップ2：refactorが存在する場合、セッションファイルを読み込む：
コマンド：Read refactor/state.json
コマンド：Read refactor/plan.md

これらの間違ったパスは使用しないでください：
- ../../../refactor/  （間違い - ディレクトリを上がる）
- $HOME/refactor/  （間違い - ホームディレクトリ）
- ~/refactor/  （間違い - ホームディレクトリ）

refactor/（現在のディレクトリ）のみを使用してください
```

**重要:** refactorフォルダは、ユーザーがコマンドを実行している現在の作業ディレクトリに作成されます。ホームディレクトリや親ディレクトリではありません。

コードベースを調査して改善の機会を特定します：

**分析の焦点:**
- **Grep**パターンを使用したコードの複雑さのホットスポット
- ファイル間の重複検出
- アーキテクチャの不整合
- 安全なリファクタリングのためのテストカバレッジ
- パフォーマンスのボトルネック

**スマートなスコープ設定:**
- 特定のファイルが提供された場合：焦点を絞った分析
- ディレクトリが提供された場合：再帰的な分析
- 引数がない場合：戦略的なプロジェクト全体のスキャン

## フェーズ2：リファクタリング計画

分析に基づいて、構造化された計画を作成します：

**リファクタリングカテゴリ:**
- **迅速な勝利**: 変数の名前変更、メソッドの抽出
- **構造的**: パターンの適用、依存関係の改善
- **アーキテクチャ**: 主要な再編成、モジュールの境界
- **パフォーマンス**: アルゴリズムの最適化、キャッシング戦略

**計画の構造:**
`refactor/plan.md`に詳細な計画を作成します：

```markdown
# リファクタリング計画 - [タイムスタンプ]

## 初期状態分析
- **現在のアーキテクチャ**: [既存のパターンの説明]
- **問題領域**: [見つかった特定の問題]
- **依存関係**: [外部/内部の依存関係]
- **テストカバレッジ**: [現在のカバレッジ%]

## リファクタリングタスク
[リスクレベル付きの優先順位付けされたリスト]

## 検証チェックリスト
- [ ] すべての古いパターンが削除された
- [ ] 壊れたインポートがない
- [ ] すべてのテストがパスしている
- [ ] ビルドが成功した
- [ ] 型チェックがクリーンである
- [ ] 孤立したコードがない
- [ ] ドキュメントが更新された

## De-Paraマッピング
| 以前 | 以後 | ステータス |
|---|---|---|
| OldService.method() | NewService.method() | 保留中 |
| /api/v1/* | /api/v2/* | 保留中 |
```

## フェーズ3：段階的な実行

体系的にリファクタリングを適用します：

**実行順序:**
1. 安全のためにgitチェックポイントを作成
2. 最初に低リスクの改善を適用
3. 各変更後に検証
4. より影響の大きいリファクタリングに進む
5. 完了ステータスで計画を更新

**継続的な検証と改良:**
すべてのリファクタリング変更後：
1. **即時テスト:**
   - 変更されたファイルの単体テストを実行
   - 該当する場合は統合テストを実行
   - テストのリグレッションがないことを確認
   
2. **詳細な比較:**
   - 変更前後の関数の出力を比較
   - APIコントラクトが維持されていることを検証
   - 見逃されたエッジケースをチェック
   - エラー処理が維持されていることを確認
   
3. **自動修正:**
   - 壊れたインポートを自動的に更新
   - 参照エラーを修正
   - 型定義を調整
   - リンティングの問題を解決
   
4. **品質ゲート:**
   - テストが失敗した場合は停止 - すぐに修正
   - 動作が変更された場合は停止 - 調査
   - パフォーマンスが低下した場合は停止 - 最適化
   - 100%検証された場合にのみ続行

5. **継続的な改良:**
   - 見逃されたパターンを再スキャン
   - すべての関連ファイルを更新
   - 孤立したコードをクリーンアップ
   - 破壊的変更を文書化

## フェーズ4：パターンの適用

一貫したパターンを全体に適用します：

**パターン認識:**
- コード内の既存のパターンを特定
- 排除すべきアンチパターンを検出
- 有益な場合にデザインパターンを適用
- アーキテクチャの一貫性を維持

**コードの改善:**
- 重複したコードをユーティリティに抽出
- 複雑な関数を単純化
- 明確さのために命名を改善
- モジュール間の結合を減らす

## フェーズ5：品質メトリクス

リファクタリングの影響を追跡します：

**測定可能な改善:**
- 複雑さの削減率
- 重複排除数
- テストカバレッジの維持
- パフォーマンスベンチマーク
- コードの可読性スコア

## コンテキストの継続性

**セッション管理:**
あなたが戻ってきて`/refactor`または`/refactor resume`を実行すると：
- 既存の計画と状態をロードします
- 進捗の要約を表示します
- 最後のチェックポイントから続行します
- すべてのリファクタリングの決定を維持します

**進捗の例:**
```
リファクタリングセッションを再開中
├── セッション: refactor_2025_08_02_1430
├── 進捗: 20タスク中12タスク完了
├── 最後のアクション: UserServiceメソッドの抽出
└── 次へ: PaymentProcessorロジックの単純化

チェックポイントから続行中...
```

## 実用的な例

**リファクタリングの開始:**
```
/refactor                    # プロジェクト全体を分析
/refactor src/components/    # 特定のディレクトリに焦点を当てる
/refactor UserService.ts     # 単一ファイルをターゲットにする
```

**セッション制御:**
```
/refactor resume    # 既存のセッションを続行
/refactor status    # 続行せずに進捗を確認
/refactor new       # 新規開始（既存のものをアーカイブ）
/refactor validate  # 完全性を検証し、未処理の部分を見つける
```

**詳細な検証と拡張コマンド:**
```
/refactor finish    # 完全な検証と動作比較で完了
/refactor enhance   # オリジナルとリファクタリング後を詳細に比較分析
/refactor verify    # オリジナルコードを実行し、動作をキャプチャし、新しいものと比較
/refactor complete  # 動作の維持を伴う100%の移行を保証
```

## フェーズ6：自動最終検証と改良

**自動実行:** このフェーズは、すべてのリファクタリングが完了した後に自動的に実行されます。`/refactor validate`で手動でトリガーすることもできます。

**最終検証プロセス:**

**詳細な検証分析:**
1. **カバレッジチェック** - 残っているすべての古いパターンを見つける
2. **インポート検証** - 壊れたまたは孤立したインポートを検出
3. **ビルドとテスト** - 完全なビルドとテストスイートを実行
4. **型チェック** - 該当する場合は型安全性を検証
5. **デッドコード検出** - 削除可能なレガシーコードを特定

**De-Paraマッピング:**
```
移行ステータスレポート
├── 移行されたパターン：48分の45（94%）
├── 更新されたファイル：70分の67
├── テストステータス：3つ失敗
└── ビルドステータス：成功

保留中の移行：
- src/legacy/UserHelper.js → まだ古いパターンを使用
- api/v1/routes.js → 混合パターンが検出されました
- tests/old-api.test.js → 更新が必要

提案された改良：
1. 12個の孤立したファイルを削除
2. 重複したユーティリティを統合
3. 3つの見逃されたインポートパスを更新
4. バンドルサイズを最適化（-15KB可能）
```

**検証アクション:**
- 包括的なde-paraドキュメントを生成
- チーム向けの移行ガイドを作成
- 残りの問題を自動的に修正
- 100%のパターンの一貫性を確保

## 詳細な検証コマンド（オールインワンプロセス）

**これらのコマンド（`finish`、`enhance`、`verify`、`complete`）はすべて、同じ包括的な検証プロセスを実行します：**

### 完全な検証と拡張プロセス
これらのいずれかを実行すると：`/refactor finish`、`/refactor enhance`、`/refactor verify`、または`/refactor complete`

**自動的にこれらのステップをすべて実行します：**

1. **詳細なオリジナルコード分析**
   - すべての関数、メソッド、クラスを詳細に分析
   - すべての動作、パターン、ロジックフローを文書化
   - 完全なコード構造と依存関係をマッピング
   - `refactor/original-analysis.md`に包括的な理解を作成

2. **完全な移行**
   - 残りのすべてのリファクタリングを適用
   - 古いパターンのすべてのインスタンスを見つけて修正
   - すべてのインポートと参照を更新
   - すべての孤立したコードをクリーンアップ

3. **詳細なコード間比較**
   - リファクタリングされたコードを一行ずつ分析
   - すべての動作が維持されていることを検証
   - すべてのロジックパスがオリジナルと一致することを確認
   - エラー処理が同一であることを確認

4. **包括的な分析**
   - 一行ずつのコード比較
   - 複雑さのメトリクス（変更前/後）
   - パフォーマンスベンチマーク
   - メモリ使用量分析
   - テストカバレッジの検証

5. **自動修正**
   - 動作の不一致を修正
   - 壊れた参照を更新
   - 型の問題を解決
   - インポートパスを修正

6. **最終検証**
   - 完全なテストスイートを実行
   - 統合テストを実行
   - ビルドがパスすることを確認
   - 100%の動作維持を保証

7. **完全なレポート**
   - すべての変更のde-paraマッピング
   - チーム向けの移行ガイド
   - リスク評価
   - 必要に応じてロールバック手順

**結果:** 何も壊れておらず、何も取り残されておらず、アプリケーションがリファクタリング前とまったく同じように動作することを100%保証します。

## 安全性の保証

**保護措置:**
- 変更前のgitチェックポイント
- 論理的なポイントでの段階的なコミット
- 各ステップ後のテスト検証
- 明確なロールバック戦略

**重要:** 私は決して以下のことは行いません：
- AIの帰属や署名を追加する
- gitの設定を変更する
- 動作している機能を壊す
- 検証なしで変更を加える
- コミット、PR、またはgit関連のコンテンツで絵文字を使用する

## コマンド統合

適切な場合、他のコマンドの使用を提案することがあります：
- `/test` - 大規模なリファクタリング後に機能を検証するため
- `/commit` - リファクタリングプロセスの論理的なチェックポイントで

## 実行の保証

**私のワークフローは常にこの順序に従います：**

1. **セッションの設定** - 最初に状態ファイルを確認/作成
2. **詳細な分析** - 複雑なシナリオには拡張思考を使用
3. **計画の作成** - すべての変更を`refactor/plan.md`に文書化
4. **確認を得る** - 開始前に計画の要約を示す
5. **段階的に実行** - チェックポイント付きで計画に従う
6. **完全性を検証** - 要求されたときに検証フェーズを実行

**私は決して以下のことは行いません：**
- 書かれた計画なしにリファクタリングを開始する
- 完全な分析前に変更を加える
- セッションファイルの作成をスキップする
- 最初に計画を示さずに進める

セッション間で完全な継続性を確保し、常に完全なコンテキストと決定履歴を持って中断したところから正確に再開します。
