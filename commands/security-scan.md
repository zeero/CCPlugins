# セキュリティ分析

セッションをまたいで追跡と修正の継続性を持ちながら、包括的なセキュリティ分析を実行します。

引数: `$ARGUMENTS` - 特定のパスまたはセキュリティの焦点領域

## セッションインテリジェンス

セキュリティ修正の進捗を維持します：

**セッションファイル（現在のプロジェクトディレクトリ内）:**
- `security-scan/plan.md` - すべての脆弱性と修正
- `security-scan/state.json` - 修正の進捗

**重要:** セッションファイルは、現在のプロジェクトルートの`security-scan`フォルダに保存されます

**自動検出:**
- セッションが存在する場合：修正済み対保留中の脆弱性を表示
- セッションがない場合：新しいセキュリティスキャンを実行
- コマンド：`resume`、`status`、`new`

## フェーズ1：セキュリティ評価

### セキュリティ分析のための拡張思考

複雑なセキュリティシナリオでは、高度な脆弱性を特定するために拡張思考を使用します：

<think>
セキュリティを分析する際：
- すぐには明らかでない攻撃ベクトル
- 個々には無害に見える連鎖的な脆弱性
- 悪用を可能にするビジネスロジックの欠陥
- タイミング攻撃と競合状態
- 依存関係におけるサプライチェーンの脆弱性
- 横方向の移動を可能にするアーキテクチャの弱点
</think>

**拡張分析のトリガー:**
- 認証および認可システム
- 金融取引処理
- 暗号実装
- マルチテナントアーキテクチャ
- APIセキュリティ境界

**必須の最初のステップ:**
1. 現在の作業ディレクトリに`security-scan`ディレクトリが存在するか確認
2. ディレクトリが存在する場合、セッションファイルを確認：
   - `security-scan/state.json`を探す
   - `security-scan/plan.md`を探す
   - 見つかった場合、既存のセッションから再開
3. ディレクトリまたはセッションが存在しない場合：
   - 完全なセキュリティスキャンを実行
   - 脆弱性レポートを作成
   - 追跡を初期化
4. 修正前にリスクの要約を表示

**注意:** 常に現在のプロジェクトの`security-scan/`フォルダでセッションファイルを探し、`../../../security-scan/`や絶対パスではありません

次元を超えてセキュリティを分析します：

**脆弱性検出:**
- ハードコードされたシークレットと資格情報
- 依存関係の脆弱性
- 安全でない設定
- 入力検証の問題
- 認証の弱点

**リスク分類:**
- **クリティカル**: 即時の悪用が可能
- **高**: 重大な脆弱性
- **中**: 対処すべき
- **低**: ベストプラクティスの改善

## フェーズ2：修正計画

検出結果に基づいて、修正計画を作成します：

**優先順位:**
1. クリティカルな資格情報の露出
2. 高リスクの脆弱性
3. 依存関係の更新
4. 設定の強化
5. コードパターンの改善

この計画を`security-scan/plan.md`に書き込みます：
- 各脆弱性の詳細
- リスク評価
- 修正アプローチ
- 検証方法

## フェーズ3：インテリジェントな修正

脆弱性を適切に修正します：

**修正パターン:**
- シークレット → 環境変数
- ハードコードされた値 → 設定ファイル
- 弱い検証 → 強力なパターン
- 古い依存関係 → 安全な更新

**安全な実践:**
- 機密データを決してログに記録しない
- 安全なデフォルトを使用する
- 最小権限の原則を適用する
- 多層防御を実装する

## フェーズ4：段階的な修正

体系的に修正します：

**実行プロセス:**
1. gitチェックポイントを作成
2. 脆弱性を安全に修正
3. 修正が機能を壊さないことを確認
4. 完了をもって計画を更新
5. 次の脆弱性に移動

**進捗追跡:**
- 計画内の各修正をマーク
- 決定事項を状態で更新
- セキュリティに焦点を当てたコミットを作成

## フェーズ5：検証

各修正の後：
- 機能が維持されていることをテスト
- 脆弱性が解決されたことを確認
- 新しい問題が導入されていないかチェック
- セキュリティドキュメントを更新

## コンテキストの継続性

**セッションの再開:**
あなたが戻ってきて`/security-scan`または`/security-scan resume`を実行すると：
- 脆弱性リストと進捗をロード
- 修正統計を表示
- 最後の修正から続行
- 修正の決定を維持

**進捗の例:**
```
セキュリティ修正を再開中
├── 脆弱性合計：23
├── 修正済み：15 (65%)
├── クリティカル：残り0
├── 高：残り3
└── 次へ：UserQueryのSQLインジェクション

修正を続行中...
```

## 実用的な例

**スキャンの開始:**
```
/security-scan                # プロジェクト全体のスキャン
/security-scan src/api/       # APIに焦点を当てる
/security-scan "credentials"  # 資格情報に焦点を当てる
```

**セッション制御:**
```
/security-scan resume    # 修正を続行
/security-scan status    # 進捗を確認
/security-scan new       # 新規スキャン
```

## 安全性の保証

**保護措置:**
- 修正前のgitチェックポイント
- 機能の維持
- セキュリティのリグレッションなし
- 明確な監査証跡

**重要:** 私は決して以下のことは行いません：
- コミットにシークレットを公開する
- 既存のセキュリティを壊す
- AIの帰属を追加する
- 機密データをログに記録する

## コマンド統合

重要なセキュリティ修正に適切な場合：
- `/test` - セキュリティパッチ後の機能を検証するため
- `/commit` - 適切なメッセージでセキュリティに焦点を当てたコミットを作成するため

## 私が実際に何をするか

1. **詳細な分析** - 複雑な脅威には拡張思考を使用
2. **徹底的にスキャン** - すべての脆弱性を見つける
3. **賢明に優先順位付け** - 重要な問題が最初
4. **安全に修正** - 機能を維持
5. **完全に追跡** - 完全な継続性
6. **常に検証** - セキュリティが向上したことを確認

セッション間で完全な継続性を維持し、常に完全な修正コンテキストで中断したところから正確に再開します。
