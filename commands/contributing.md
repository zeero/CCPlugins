# 貢献戦略の完成 - コンテキスト認識

現在のコンテキストと作業に基づいて、貢献が成功するために必要なすべてを分析します。

## 戦略的思考プロセス

<think>
貢献を成功させるためには、以下を分析する必要があります：

1. **現在の作業コンテキスト**
   - このセッションで何が行われましたか？
   - 実装の途中ですか、それとも完了後ですか？
   - どのような種類の変更が行われましたか（機能、修正、リファクタリング）？
   - 作業は貢献の準備ができていますか？

2. **プロジェクトの種類と標準**
   - これはオープンソース、企業、または個人プロジェクトですか？
   - 貢献のガイドラインは何ですか？
   - 従うべき特定のワークフローはありますか？
   - どのような品質ゲートが存在しますか（テスト、リント、レビュー）？

3. **貢献戦略**
   - これは1つのPRにすべきですか、それとも複数にすべきですか？
   - この作業はどのイシューに対応していますか？
   - どのドキュメントを更新する必要がありますか？
   - 誰がこれをレビューすべきですか？

4. **飛行前チェックリスト**
   - すべてのテストはパスしますか？
   - コードは適切にフォーマットされていますか？
   - リントの警告はありますか？
   - ドキュメントは更新されていますか？
   - コミットはよく整理されていますか？
</think>

このフレームワークに基づいて、まずあなたのコンテキストを検出することから始めます：

**最初にコンテキストを検出:**
あなたがどのような状況にあるかを理解させてください：

1. **アクティブなセッションコンテキスト**（あなたが実装していた場合）：
   - CLAUDE.mdを読んでセッションの目標と行われた作業を理解する
   - セッション中に変更されたすべてのファイルを分析する
   - テストが実行され、パスしたかを確認する
   - セッション中に行われたコミットを確認する
   - 変更の完全な範囲を理解する

2. **実装後のコンテキスト**（機能が完成している場合）：
   - 完成した機能/修正を検出する
   - 新しいコードのテストカバレッジを確認する
   - ドキュメントが更新されたことを確認する
   - コードの品質と標準を分析する

3. **開発途中のコンテキスト**（作業中の場合）：
   - 完了したこととTODOを特定する
   - 部分的な実装を確認する
   - 貢献の準備状況を評価する

4. **コールドスタートコンテキスト**（最近の作業がない場合）：
   - 既存の未コミットの変更を分析する
   - mainブランチとの差分を確認する
   - プロジェクトの状態を理解する

**スマートなコンテキスト分析:**
見つけたものに基づいて、アプローチを適応させます：
- **セッション作業**: すべてのセッションの変更を適切にパッケージ化する
- **複数の機能**: PRに分割することを提案する
- **バグ修正**: 簡単な貢献を迅速に進める
- **主要な変更**: 完全な貢献ワークフロー

**フェーズ0：必須の飛行前チェック**
何よりも先に、以下を確認する必要があります：
- **ビルドがパスする**: プロジェクトのビルドコマンドを実行
- **テストがパスする**: すべてのテストがグリーンであること
- **リントがパスする**: リンティングエラーがないこと
- **型チェックがパスする**: TypeScript/Flowなどの場合
- **フォーマットチェック**: コードが適切にフォーマットされていること

いずれかのチェックが失敗した場合 → 停止して最初に修正！

**フェーズ1：詳細なコンテキスト分析**
あなたの状況についてすべてを理解します：

**A. セッションコンテキスト**（作業していた場合）：
   - CLAUDE.mdを読んで完全なセッション履歴を理解する
   - セッション中に変更されたすべてのファイルを分析する
   - `/test`の実行からのテスト結果を確認する
   - `/review`または`/security-scan`の結果を確認する
   - 実装された機能を理解する

**B. コールドスタートコンテキスト**（スタンドアロンで実行する場合）：
   - `/understand`を実行してコードベース全体をマッピングする
   - リモートに対するすべてのローカルコミットを分析する
   - 未コミットの変更を検出する
   - フォークとアップストリームを比較する（該当する場合）
   - あなたのバージョンをユニークにしているものを特定する

**C. 実装コンテキスト**:
- 複数の機能が完了 → スマートなPR分割
- バグ修正が完了 → イシュートラッカーへのリンク
- テストが追加された → カバレッジレポートの更新
- ドキュメントが更新された → 一貫性の確保

**フェーズ2：プロジェクトタイプの検出**
これがどのようなプロジェクトかを特定します：
- **オープンソース**: 完全なCONTRIBUTING.mdの遵守が必要
- **企業/チーム**: 内部の標準とワークフロー
- **個人**: あなた自身の慣習
- **フォーク**: アップストリームプロジェクトの要件
- **クライアントワーク**: 特定の成果物

**フェーズ3：リポジトリ標準の分析**
プロジェクトタイプに基づいて、以下を調査します：
- CONTRIBUTING.md、README.md、CHANGELOG.md、LICENSEファイルを**読む**
- .githubのワークフロー、イシューテンプレート、PRテンプレートを**分析する**
- コードパターン、命名規則、アーキテクチャの決定を**確認する**
- メンテナーの好みとパターンについてコミット履歴を**レビューする**
- 特定の要件（DCO、CLA、テスト、ドキュメント）を**検出する**

**フェーズ4：スマートな比較**
あなたの作業を要件と比較します：
- **機能の完全性**: すべての受け入れ基準が満たされていますか？
- **テストカバレッジ**: 新しいコードは適切にテストされていますか？
- **ドキュメンテーション**: 機能は文書化されていますか？
- **コード標準**: プロジェクトのスタイルに従っていますか？
- **破壊的変更**: 適切に処理されていますか？

**フェーズ5：コンテキストに応じたアクションプラン**
あなたの特定の状況に基づいて：

**セッションを終えたばかりの場合:**
- すべてのセッション作業をまとまりのあるPRにパッケージ化する
- 包括的なテストレポートを生成する
- セッションベースのPR説明を作成する
- セッションで言及されたイシューにリンクする

**複数の機能がある場合:**
- 論理的なPRの分割を提案する
- 依存関係に基づいてPRを順序付ける
- それぞれのトラッキング用のイシューを作成する

**オープンソースに貢献する場合:**
- 完全なCONTRIBUTING.mdのコンプライアンスチェック
- DCO/CLA署名の検証
- コミュニティガイドラインの遵守
- イシューのリンケージと適切なラベル

**フェーズ6：インテリジェントなリモートリポジトリスキャン**
PRの受け入れを最大化するために、リモートリポジトリの詳細なスキャンを行います：

**自動イシュー発見とリンケージ:**
変更を加えたとき、以下を検索します：
- **バグレポート**: "error"、"bug"、"broken" + 修正したファイル
- **機能リクエスト**: "feature"、"enhancement" + 実装した機能
- **改善**: "performance"、"refactor" + 最適化
- **ドキュメンテーション**: "docs"、"readme" + ドキュメントの更新

**スマートマッチングアルゴリズム:**
あなたが行った各変更について：
1. コードの変更からキーワードを抽出する
2. リモートイシューで一致するものを検索する
3. イシューの説明とコメントを分析する
4. リンクするのに最適な一致を見つける

**プロアクティブなイシュー作成:**
一致するイシューが存在しない場合：
1. 変更の種類（バグ修正、機能など）を検出する
2. プロジェクトのイシューテンプレートを使用する
3. プロジェクトのスタイルでイシューを作成する（絵文字なし）：
   - バグ：再現手順、期待される動作と実際の動作
   - 機能：ユーザーストーリー、利点、実装
   - 拡張：現在の動作と改善された動作
   - プロフェッショナルなトーン：直接的、事実に基づき、簡潔
4. プロジェクトのラベリング規則に従う

**Gitワークフローの検出:**
プロジェクトのワークフローを分析します：
- **Git Flow**: feature/*, hotfix/*, release/*
- **GitHub Flow**: featureブランチ → main
- **GitLab Flow**: 環境ブランチ
- **カスタム**: 既存のPRから検出

**スマートPR戦略:**
見つけたものに基づいて：
- **イシューが存在する場合**: "Fixes #X"、"Closes #Y"でリンクする
- **イシューがない場合**: 最初に作成してからリンクする
- **複数のイシュー**: イシューごとに1つのPR、または論理的にグループ化
- **ディスカッションスレッド**: "See #Z"で参照する

**PR/イシュースタイル:**
- **簡潔なタイトル**: "Fixed the authentication validation bug that was causing issues"ではなく"Fix auth validation bug"
- **箇条書き**: 段落ではなくリストを使用
- **絵文字なし**: プロフェッショナルなトーンのみ
- **直接的な言葉遣い**: "I hope this PR might help with X"ではなく"This PR fixes X"
- **プロジェクトのトーンに合わせる**: 既存のPRを分析してスタイルを合わせる

**フェーズ7：スマートなデシジョンツリー**
複数の項目を見つけた場合、優先順位を付けたアクションを含むtodoリストを作成します：
- PRの受け入れを妨げる可能性のある**重要な項目**
- 承認の可能性を高めるための**推奨される改善**
- プロジェクトのパターンに基づいた**任意の拡張**

具体的なガイダンスを提供します：
- 更新する正確なファイルとその方法
- 必要なドキュメントの変更
- プロジェクトに合ったテスト戦略
- プロジェクト標準に従ったPR説明テンプレート

**コンテキストベースのオプション**: "どのように進めますか？"

**セッション作業の場合:**
- "セッション作業をPRにパッケージ化する" - すべてのセッションの変更からPRを作成します
- "TODOのイシューを作成する" - 残りの作業を追跡します
- "複数のPRに分割する" - 複数の機能を実装した場合

**オープンソースへの貢献の場合:**
- "完全なコンプライアンスチェックとPR" - 完全なCONTRIBUTINGワークフロー
- "最初にトラッキングイシューを作成する" - 複雑な機能の場合
- "クイックフィックスPR" - 簡単なバグ修正の場合

**チーム/企業プロジェクトの場合:**
- "内部プロセスに従う" - あなたのチームの特定のワークフロー
- "機能ブランチPRを作成する" - 標準的なgit flow
- "最初にステージングにデプロイする" - 必要な場合

**スマートPR作成:**
コンテキストに基づいて、以下を行います：
- PRの説明にセッションの要約を使用する
- テスト結果を自動的に含める
- 関連するイシュー/ディスカッションにリンクする
- プロジェクトのPRテンプレートに正確に従う
- 適切なラベルとレビュー担当者を追加する

**自動化されたワークフローオプション:**

**オプション1：「イシュー管理付きの完全自動デプロイ」**:
```bash
# 自動的に以下を実行します：
1. 最初にすべてのチェックを実行：
   - ビルドがパスすること
   - すべてのテストがパスすること
   - リントがパスすること
   - 型チェックがパスすること
2. すべてがパスした場合のみ、次に進む：
3. 関連するすべてのイシューをリモートでスキャンする
4. 変更に対して不足しているイシューを作成する
5. CHANGELOG.mdを更新する
6. 適切なブランチ（feature/fix/など）を作成する
7. 変更をプッシュする
8. 以下を含むPRを作成する：
   - 関連するすべてのイシューへのリンク
   - バグに対する"Fixes #123"
   - 機能に対する"Implements #456"
   - テンプレートに従った完璧な説明
9. ラベルを追加し、レビュー担当者をリクエストする
```

**オプション2：「すべてを準備する」**（プッシュ前にレビュー）：
```bash
# 準備しますが、レビューしてもらいます：
1. すべての変更を適切にステージングする
2. PRの説明を生成する
3. イシューリンクを作成する
4. プッシュする前にすべてを表示する
```

**オプション3：「分析のみ」**（何が必要かを確認）：
```bash
# 分析して報告します：
1. 準備ができているものと不足しているもの
2. コンプライアンスのギャップ
3. 提案された改善点
4. イシューの機会
```

**フォーク固有のインテリジェンス:**
- アップストリームの変更と比較する
- 必要に応じてリベースを提案する
- 競合を早期に特定する
- アップストリームでの受け入れのためにフォーマットする

**インテリジェントなセッション分析の例:**
作業中に変更を加えた場合：
```
あなた: /contributing

私: セッションを分析しています...
- 発見: UserService.jsの認証バグを修正しました
- 発見: レート制限機能を追加しました
- 発見: APIのパフォーマンスを改善しました

リモートリポジトリをスキャンしています...
- イシュー #45: "認証がランダムに失敗する" → あなたの修正がこれに対応しています！
- イシュー #67: "レート制限が必要" → あなたがこれを実装しました！
- パフォーマンス改善のイシューなし → 私が作成します

オプション:
1. パフォーマンスのイシューを作成 + 3つのPR（イシューごとに1つ）
2. イシューを作成 + 3つすべてを修正する1つのPR
3. レビューのためにすべてを準備するだけ
```

**実装後の自動アクション:**
- リンク可能なイシューをリモートでスキャンする
- 不足しているイシューを自動的に作成する
- 変更されたすべてのファイルで`/format`を実行する
- すべてがパスすることを確認するために`/test`を実行する
- ドキュメントを更新するために`/docs`を実行する
- 最大限のコンテキストを持つPRを作成する

**重要**: 私は決して以下のことは行いません：
- "Created by Claude"やAIの帰属をイシュー/PRに追加する
- "Generated with Claude Code"を説明に含める
- リポジトリの設定や権限を変更する
- AI/アシスタントの署名や透かしを追加する
- PR、イシュー、またはコミットメッセージで絵文字を使用する
- 説明で不必要に冗長になる
- 派手な言葉遣いや過剰な説明を加える
- **テストにパスせずにGITHUBにプッシュする**
- **ビルドが壊れている場合にPRを作成する**
- **リントエラーのあるコードを提出する**

**プロフェッショナルスタンダード:**
- **簡潔であること**: 要点を素早く伝える
- **客観的であること**: 感情よりも事実
- **プロジェクトのスタイルに従う**: 既存のPR/イシューのトーンに合わせる
- **絵文字なし**: プロフェッショナルに保つ
- **明確で直接的**: 何がなぜ変更されたか
- **実践的な焦点**: 重要な実装の詳細

これにより、すべてのプロジェクト標準とコミュニティの期待に従い、重複作業を避けることで、PRの受け入れ確率を最大化します。
